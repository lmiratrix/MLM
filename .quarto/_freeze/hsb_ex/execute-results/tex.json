{
  "hash": "5c0d78a93ab73a29ecf3dac3a934e965",
  "result": {
    "markdown": "---\ntitle: \"HSB Example\"\nauthor: \"Luke Miratrix\"\neditor: \n  markdown: \n    wrap: sentence\n---\n\n::: {.cell}\n\n:::\n\n\n\n## R Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(foreign) #this lets us read in spss files\nlibrary(tidyverse) #this is a broad package that allows us to do lots of data management-y things (and ggplot!)\nlibrary(lme4) #this allows us to run MLM\nlibrary(arm) #this allows us to display MLM\nlibrary( lmerTest ) # this puts p-values on the summary() command for fixed effects\n```\n:::\n\n\n\n## Load HS&B data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read student data\nstud.dat = read.spss( \"data/hsb1.sav\", to.data.frame=TRUE )\n\n# Read in school data\nsch.dat = read.spss( \"data/hsb2.sav\", to.data.frame=TRUE )\n\n# Make single data frame with all variables, keep all students even if they\n# don't match to a school\ndat = merge( stud.dat, sch.dat, by=\"id\", all.x=TRUE )\n```\n:::\n\n\n\n## Table 4.1 Descriptive summaries\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Get mean and SD of the Level 1 variables, rounded to 2 decimal places\n# math achievement\nround(mean(dat$mathach),2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12.75\n```\n:::\n\n```{.r .cell-code}\nround(sd(dat$mathach),2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6.88\n```\n:::\n\n```{.r .cell-code}\n# ses\nround(mean(dat$ses),2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nround(sd(dat$ses),2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.78\n```\n:::\n\n```{.r .cell-code}\n## Get mean and SD of Level 2 variables, round to 2 decimal places\n# NOTE: we are getting these from the SCHOOL-LEVEL FILE\n# sector\nround(mean(sch.dat$sector),2) # this answers \"what percent of schools are catholic?\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.44\n```\n:::\n\n```{.r .cell-code}\nround(sd(sch.dat$sector),2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5\n```\n:::\n\n```{.r .cell-code}\n# mean ses\nround(mean(sch.dat$meanses),2) # this answers \"what is the average of the school-average SES values?\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nround(sd(sch.dat$meanses),2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.41\n```\n:::\n\n```{.r .cell-code}\n# NOTE: if we used the student-level or \"dat\" file, we would be answering the\n# following questions:\n# * what percent of students attend a catholic school?\n# * what is the average student ses? <- this would match what we calculated\n# ourselves if we had the entire school in our sample\n```\n:::\n\n\n\n## Table 4.2: One-Way ANOVA (i.e uncontrolled random intercept)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Fit the model described \nmod4.2 <- lmer(mathach ~ 1 + (1|id), data=dat)\n# Peek at the results\ndisplay(mod4.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlmer(formula = mathach ~ 1 + (1 | id), data = dat)\ncoef.est  coef.se \n   12.64     0.24 \n\nError terms:\n Groups   Name        Std.Dev.\n id       (Intercept) 2.93    \n Residual             6.26    \n---\nnumber of obs: 7185, groups: id, 160\nAIC = 47122.8, DIC = 47114.8\ndeviance = 47115.8 \n```\n:::\n\n```{.r .cell-code}\n## Extract the fixed effect coefficient (and it's standard error)\nfixef(mod4.2) # extracts the fixed effect coefficient(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept) \n   12.63697 \n```\n:::\n\n```{.r .cell-code}\nse.coef(mod4.2)$fixef #extracts the standard errors for the fixed effect(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2443936\n```\n:::\n\n```{.r .cell-code}\n## Extract the variance components\n# Note: in the model display, we see the SDs, not the variance\nVarCorr(mod4.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Groups   Name        Std.Dev.\n id       (Intercept) 2.9350  \n Residual             6.2569  \n```\n:::\n\n```{.r .cell-code}\n# To get the variances, we extract each part and square it\n# variance of random intercept\n(sigma.hat(mod4.2)$sigma$id)^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept) \n   8.614025 \n```\n:::\n\n```{.r .cell-code}\n# variance of level 1 residual (easier to extract)\nsigma(mod4.2)^2 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 39.14832\n```\n:::\n\n```{.r .cell-code}\n# could also use the more complicated formula that we used with the intercept.\n# If we do, we get the same thing\nsigma.hat(mod4.2)$sigma$data^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 39.14832\n```\n:::\n\n```{.r .cell-code}\n# Inference on the need for a random intercept\n# Thus uses the book's way of calculating a test statistic with a\n# chi-squared distribution.\n\nschools = dat %>% group_by( id ) %>%\n  summarise( nj = n(),\n             Y.bar.j = mean( mathach ) )\ngamma.00 = fixef( mod4.2 )[[1]]\nsigma.2 = sigma(mod4.2)^2 \nH = sum( schools$nj * (schools$Y.bar.j - gamma.00)^2 / sigma.2 )\nH\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1660.232\n```\n:::\n\n```{.r .cell-code}\n# our p-value\npchisq( H, df = nrow( schools ) - 1, lower.tail = FALSE )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.770612e-248\n```\n:::\n\n```{.r .cell-code}\n# calculating the ICC\ntau.00 = VarCorr(mod4.2)$id[1,1]\nrho.hat = tau.00 / (tau.00 + sigma.2 )\nrho.hat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1803518\n```\n:::\n\n```{.r .cell-code}\n# Calculating reliability for each school mean. (Here it is purely a function of\n# students in the school.  More students, more info, and thus more reliable.)\nsigma.2 = sigma(mod4.2)^2 \ntau.00 = VarCorr(mod4.2)$id[1,1]\nlambda = tau.00 / ( tau.00 + sigma.2 / schools$nj )\nmean( lambda )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.9013773\n```\n:::\n\n```{.r .cell-code}\n# A bonus graph of the reliabilities\nqplot( lambda )\n```\n\n::: {.cell-output-display}\n![](hsb_ex_files/figure-pdf/unnamed-chunk-5-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Table 4.3 Means as Outcomes Model\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (i.e. random intercept with Level 2 predictor)\n## Fit the model described \nmod4.3 <- lmer(mathach ~ 1 + meanses + (1|id), data=dat)\n\n# Peek at the results\ndisplay(mod4.3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlmer(formula = mathach ~ 1 + meanses + (1 | id), data = dat)\n            coef.est coef.se\n(Intercept) 12.65     0.15  \nmeanses      5.86     0.36  \n\nError terms:\n Groups   Name        Std.Dev.\n id       (Intercept) 1.62    \n Residual             6.26    \n---\nnumber of obs: 7185, groups: id, 160\nAIC = 46969.3, DIC = 46956.9\ndeviance = 46959.1 \n```\n:::\n\n```{.r .cell-code}\n## Extract the fixed effect coefficients (and standard errors/t-statistics)\nfixef(mod4.3) # extracts the fixed effect coefficients\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)     meanses \n  12.649435    5.863538 \n```\n:::\n\n```{.r .cell-code}\n# NOTE: you can call them separately by \"indexing\" them\n# just the intercept\nfixef(mod4.3)[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept) \n   12.64944 \n```\n:::\n\n```{.r .cell-code}\n# just coefficient on mean ses\nfixef(mod4.3)[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n meanses \n5.863538 \n```\n:::\n\n```{.r .cell-code}\nse.coef(mod4.3)$fixef #extracts the standard errors for the fixed effect(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1492801 0.3614580\n```\n:::\n\n```{.r .cell-code}\n## Calculate (or extract) the t-ratio (aka the t-statistic)\n\n# NOTE: the author's don't present this for the intercept, because we often\n# don't care. But it is presented here for completeness\n\n# tstats for intercept\nfixef(mod4.3)[1]/se.coef(mod4.3)$fixef[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept) \n   84.73622 \n```\n:::\n\n```{.r .cell-code}\n# tstat mean ses\nfixef(mod4.3)[2]/se.coef(mod4.3)$fixef[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n meanses \n16.22191 \n```\n:::\n\n```{.r .cell-code}\n# tstat extracted - this does both variables at once! \ncoef(summary(mod4.3))[,\"t value\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)     meanses \n   84.73622    16.22191 \n```\n:::\n\n```{.r .cell-code}\n# NOTE: Let's look at what is happening here:\ncoef(summary(mod4.3)) # gives us all the fixed effect statistics we could want\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Estimate Std. Error       df  t value      Pr(>|t|)\n(Intercept) 12.649435  0.1492801 153.7425 84.73622 6.032591e-131\nmeanses      5.863538  0.3614580 153.4067 16.22191  4.267894e-35\n```\n:::\n\n```{.r .cell-code}\n# the [ ] is called \"indexing\" - it's a way of subsetting data by telling R\n# which [rows,columns] you want to see we are telling R that we want ALL rows \"[\n# ,\" but only the column labeled \"t value\"\n\n## Extract the variance components\n# Note: in the model display, we see the SDs, not the variance\nVarCorr(mod4.3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Groups   Name        Std.Dev.\n id       (Intercept) 1.6244  \n Residual             6.2576  \n```\n:::\n\n```{.r .cell-code}\n# To get the variances, we extract each part and square it\n# variance of random intercept\n(sigma.hat(mod4.3)$sigma$id)^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept) \n   2.638708 \n```\n:::\n\n```{.r .cell-code}\n# variance of level 1 residual\nsigma(mod4.3)^2 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 39.15708\n```\n:::\n\n```{.r .cell-code}\n# Range of plausible values for school means for schools with mean SES of 0:\n# See page 73-74)\nfixef( mod4.3 )[[1]] + c(-1.96, 1.96) * (sigma.hat(mod4.3)$sigma$id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  9.465592 15.833279\n```\n:::\n\n```{.r .cell-code}\n# Compare to our model without mean ses\nfixef( mod4.2 )[[1]] + c(-1.96, 1.96) * (sigma.hat(mod4.2)$sigma$id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6.884441 18.389507\n```\n:::\n\n```{.r .cell-code}\n# Proportion reduction in variance or \"variance explained\" at level 2\ntau.00.anova = (sigma.hat(mod4.2)$sigma$id)^2\ntau.00.meanses = (sigma.hat(mod4.3)$sigma$id)^2\n(tau.00.anova-tau.00.meanses) / tau.00.anova\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept) \n   0.693673 \n```\n:::\n\n```{.r .cell-code}\n## Inference on the random effects\nschools = merge( schools, sch.dat, by=\"id\" )\ngamma.00 = fixef( mod4.3 )[[1]]\ngamma.01 = fixef( mod4.3 )[[2]]\nschools = mutate( schools, resid = Y.bar.j - gamma.00 - gamma.01*meanses )\nH = sum( schools$nj * schools$resid^2 ) / sigma(mod4.3)^2 \nH\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 633.5175\n```\n:::\n\n```{.r .cell-code}\npchisq( H, nrow( schools ) - 2, lower.tail = FALSE )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.617696e-58\n```\n:::\n\n```{.r .cell-code}\n## Reliability revisited (from pg 75)\nmod4.3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLinear mixed model fit by REML ['lmerModLmerTest']\nFormula: mathach ~ 1 + meanses + (1 | id)\n   Data: dat\nREML criterion at convergence: 46961.28\nRandom effects:\n Groups   Name        Std.Dev.\n id       (Intercept) 1.624   \n Residual             6.258   \nNumber of obs: 7185, groups:  id, 160\nFixed Effects:\n(Intercept)      meanses  \n     12.649        5.864  \n```\n:::\n\n```{.r .cell-code}\nu.hat = coef( mod4.3 )$id\nhead( u.hat )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     (Intercept)  meanses\n1224    12.32688 5.863538\n1288    12.71898 5.863538\n1296    10.70101 5.863538\n1308    12.92208 5.863538\n1317    11.48086 5.863538\n1358    11.73878 5.863538\n```\n:::\n\n```{.r .cell-code}\nsigma.2 = sigma(mod4.3)^2 \ntau.00 = VarCorr(mod4.3)$id[1,1]\nsigma.2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 39.15708\n```\n:::\n\n```{.r .cell-code}\ntau.00\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.638708\n```\n:::\n\n```{.r .cell-code}\n# These are the individual reliabilities---how well we can separate schools with the same Mean SES\n# (So it is _conditional_ on the mean SES of the schools.)\nlambda.j = tau.00 / (tau.00 + (sigma.2 / schools$nj))\nmean( lambda.j )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.7400747\n```\n:::\n:::\n\n\n\n## Table 4.4 Random coefficient model (i.e. random slope)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# group-mean center ses  \ndat <- dat %>% group_by( id ) %>% \n  mutate( ses_grpcenter = ses - mean(ses) )\n\n## Fit the model described \nmod4.4 <- lmer(mathach ~ 1 + ses_grpcenter + ( 1 + ses_grpcenter | id ), data=dat)\n# Peek at the results\ndisplay(mod4.4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlmer(formula = mathach ~ 1 + ses_grpcenter + (1 + ses_grpcenter | \n    id), data = dat)\n              coef.est coef.se\n(Intercept)   12.64     0.24  \nses_grpcenter  2.19     0.13  \n\nError terms:\n Groups   Name          Std.Dev. Corr \n id       (Intercept)   2.95          \n          ses_grpcenter 0.83     0.02 \n Residual               6.06          \n---\nnumber of obs: 7185, groups: id, 160\nAIC = 46726.2, DIC = 46707.7\ndeviance = 46711.0 \n```\n:::\n\n```{.r .cell-code}\n## Extract the fixed effect coefficients (and standard errors/t-statistics)\ncoef(summary(mod4.4)) #this reproduces the whole first panel, though methods used above also work\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               Estimate Std. Error       df  t value      Pr(>|t|)\n(Intercept)   12.636193  0.2445047 156.7512 51.68077 2.286892e-100\nses_grpcenter  2.193196  0.1282589 155.2166 17.09976  1.582355e-37\n```\n:::\n\n```{.r .cell-code}\n## Extract the variance components\n# Note: in the model display, we see the SDs, not the variance\nVarCorr(mod4.4) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Groups   Name          Std.Dev. Corr \n id       (Intercept)   2.94636       \n          ses_grpcenter 0.83307  0.019\n Residual               6.05807       \n```\n:::\n\n```{.r .cell-code}\n# variance of random effects\n(sigma.hat(mod4.4)$sigma$id)^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  (Intercept) ses_grpcenter \n    8.6810437     0.6939974 \n```\n:::\n\n```{.r .cell-code}\n# NOTE: to extract one or the other, you can use indexing\n(sigma.hat(mod4.4)$sigma$id[1])^2 #this is just the intercept random effect\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept) \n   8.681044 \n```\n:::\n\n```{.r .cell-code}\n# variance of level 1 residual\nsigma(mod4.4)^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 36.70019\n```\n:::\n:::\n\n\n\n## Table 4.5 Intercepts and Slopes as Outcomes Model\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Fit the model described \nmod4.5 <- lmer(mathach ~ 1 + meanses + sector + ses_grpcenter*(meanses + sector) + ( 1 + ses_grpcenter | id ), data=dat)\n\n# NOTE: The code above allows the coefficients to appear in the same order as in Table 4.5\n\n# R automatically includes the main effects, so this model can be written more\n# concisely as shown below:\n#\n# lmer(mathach ~ 1 + ses_grpcenter*(meanses + sector) + ( 1 + ses_grpcenter | id ), data=dat)\n\n# Peek at the results\ndisplay(mod4.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlmer(formula = mathach ~ 1 + meanses + sector + ses_grpcenter * \n    (meanses + sector) + (1 + ses_grpcenter | id), data = dat)\n                      coef.est coef.se\n(Intercept)           12.10     0.20  \nmeanses                5.33     0.37  \nsector                 1.23     0.31  \nses_grpcenter          2.94     0.16  \nmeanses:ses_grpcenter  1.04     0.30  \nsector:ses_grpcenter  -1.64     0.24  \n\nError terms:\n Groups   Name          Std.Dev. Corr \n id       (Intercept)   1.54          \n          ses_grpcenter 0.32     0.39 \n Residual               6.06          \n---\nnumber of obs: 7185, groups: id, 160\nAIC = 46523.7, DIC = 46489.2\ndeviance = 46496.4 \n```\n:::\n\n```{.r .cell-code}\n## Extract the fixed effect coefficients (and standard errors/t-statistics)\n#this reproduces the whole first panel, though methods used above also work\ncoef(summary(mod4.5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                       Estimate Std. Error       df   t value      Pr(>|t|)\n(Intercept)           12.095997  0.1987329 159.9143 60.865590 1.625101e-112\nmeanses                5.332898  0.3691567 150.9836 14.446161  2.944282e-30\nsector                 1.226453  0.3062674 149.6139  4.004518  9.756638e-05\nses_grpcenter          2.938785  0.1550889 139.2934 18.949039  2.197495e-40\nmeanses:ses_grpcenter  1.038918  0.2988941 160.5429  3.475873  6.550388e-04\nsector:ses_grpcenter  -1.642619  0.2397854 143.3351 -6.850371  2.009492e-10\n```\n:::\n\n```{.r .cell-code}\n# NOTE: there is a slight descrepancy in the estimate for meanses:ses_grpcenter and \n# the t-statistics for meanses:ses_grpcenter and sector:ses_grpcenter; nothing that \n# changes the interpretations, however.\n\n\n# Testing the need for sector  (see page 82)\n# (We use a likelihood ratio test with the anova() function)\nmod4.5.null <- lmer(mathach ~ 1 + meanses + ses_grpcenter*(meanses) + ( 1 + ses_grpcenter | id ), data=dat)\nanova( mod4.5, mod4.5.null )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nData: dat\nModels:\nmod4.5.null: mathach ~ 1 + meanses + ses_grpcenter * (meanses) + (1 + ses_grpcenter | id)\nmod4.5: mathach ~ 1 + meanses + sector + ses_grpcenter * (meanses + sector) + (1 + ses_grpcenter | id)\n            npar   AIC   BIC logLik deviance  Chisq Df Pr(>Chisq)    \nmod4.5.null    8 46568 46623 -23276    46552                         \nmod4.5        10 46516 46585 -23248    46496 55.941  2  7.122e-13 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n```{.r .cell-code}\n# Testing the need for random slope  (see page 84)\n# (We use a likelihood ratio test with the anova() function)\nmod4.5.null.slope <- lmer(mathach ~ 1 + meanses + sector + ses_grpcenter*(meanses + sector) + ( 1 | id ), data=dat) \nanova( mod4.5, mod4.5.null.slope )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nData: dat\nModels:\nmod4.5.null.slope: mathach ~ 1 + meanses + sector + ses_grpcenter * (meanses + sector) + (1 | id)\nmod4.5: mathach ~ 1 + meanses + sector + ses_grpcenter * (meanses + sector) + (1 + ses_grpcenter | id)\n                  npar   AIC   BIC logLik deviance  Chisq Df Pr(>Chisq)\nmod4.5.null.slope    8 46513 46568 -23249    46497                     \nmod4.5              10 46516 46585 -23248    46496 1.0039  2     0.6054\n```\n:::\n:::\n\n\n\n## Figure 4.1\n\nNOTE: Figure 4.1 is a graphical display using the results from Model/Table 4.5\n\nThe solid line represents the slope of the gamma-01 coefficient; this is the same in public and catholic schools.\nThe dotted lines represent the the slope for individual schools with \"prototypical\" values of meanses (-1,0,1 standard deviations from mean)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# to calculate this, we should note a few values: \navg_meanses <- mean(dat$meanses) #average of mean ses var\nhigh_meanses <- mean(dat$meanses) + sd(dat$meanses) # 1 sd above avg meanses\nlow_meanses <- mean(dat$meanses) - sd(dat$meanses) # 1 sd below avg meanses\n\nfake.students = expand.grid( id = -1,\n                             meanses = c( low_meanses, avg_meanses, high_meanses ),\n                             sector = c( 0, 1 ),\n                             ses_grpcenter = c( -1, 0, 1 ) )\nfake.students = mutate( fake.students, ses = meanses + ses_grpcenter )\nfake.students$mathach = predict( mod4.5, newdata=fake.students, allow.new.levels = TRUE )\nfake.schools = filter( fake.students, ses_grpcenter == 0 )\n\nggplot( fake.students, aes( ses, mathach ) ) + \n  facet_wrap( ~ sector ) +\n  geom_line( aes( group=meanses ), lty = 2 ) +\n  geom_line( data=fake.schools, aes( x = ses, y = mathach ) ) +\n  geom_point( data=fake.schools, aes( x = ses, y = mathach ) )\n```\n\n::: {.cell-output-display}\n![](hsb_ex_files/figure-pdf/unnamed-chunk-9-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Set-up for remaining tables/figures of chapter\n\nIn order to create table 4.6 and the following 2 graphs, we will need to prepare a new dataset.\nThese next lines of code do that.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Start with school level data frame and keep variables interesting to our model comparison\nmod.comp <- dplyr::select( sch.dat, id, meanses, sector )\n\n## Add in number of observations per school \nn_j <- dat %>% group_by( id ) %>%\n  dplyr::summarise(n_j = n())\n\nmod.comp <- merge(mod.comp, n_j, by=\"id\")\nhead( mod.comp )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    id meanses sector n_j\n1 1224  -0.428      0  47\n2 1288   0.128      0  25\n3 1296  -0.420      0  48\n4 1308   0.534      1  20\n5 1317   0.351      1  48\n6 1358  -0.014      0  30\n```\n:::\n\n```{.r .cell-code}\n## Run site-specific OLS for each school and save estimates \n\n# Calculate global (not group) centered ses\ndat$ses_centered <- dat$ses - mean(dat$ses)\n\n# This is the \"for loop\" method of generating an estimate for each of many small\n# worlds (schools). See lecture 2.3 code for the \"tidyverse\" way.\nest.ols <- matrix(nrow=160,ncol=2) #create a matrix to store estimates \nse.ols <- matrix(nrow=160,ncol=2) #create matrix to store standard errors\n\nfor (i in 1:length(unique(dat$id))){ #looping across the 160 different values of id\n    id <- unique(dat$id)[i] #pick the value of id we want\n    mod <- lm(mathach ~ 1 + ses_grpcenter, data=dat[dat$id==id,]) #run the model on students in that 1 school\n    est.ols[i,] <- coef( mod ) #save the setimates in the matrix we created\n    se.ols[i,] <- se.coef( mod ) # and the SEs\n}\n\n#convert the matrix to a dataframe and attach the schoolid info\nest.ols <- as.data.frame(est.ols)\nest.ols$id <- sch.dat$id\nnames(est.ols) <- c( 'b0_ols', 'b1_ols', 'id' )\n\n#store standard errors for later\nse.ols <- as.data.frame(se.ols)\nse.ols$id <- sch.dat$id\nnames(se.ols) <- c( 'se_b0_ols', 'se_b1_ols', 'id' )\n\nmod.comp <- merge(mod.comp, est.ols, by='id')\nmod.comp <- merge(mod.comp, se.ols, by='id' )\nhead( mod.comp )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    id meanses sector n_j    b0_ols    b1_ols se_b0_ols se_b1_ols\n1 1224  -0.428      0  47  9.715447 2.5085817 1.0954478  1.765216\n2 1288   0.128      0  25 13.510800 3.2554487 1.3637656  2.079675\n3 1296  -0.420      0  48  7.635958 1.0759591 0.7740752  1.209016\n4 1308   0.534      1  20 16.255500 0.1260242 1.4045813  3.003437\n5 1317   0.351      1  48 13.177688 1.2739128 0.7902486  1.435942\n6 1358  -0.014      0  30 11.206233 5.0680087 0.8994345  1.391550\n```\n:::\n\n```{.r .cell-code}\n# We are done running OLS on each of our schools and storing the results.\n\n## Extract site-specific coefficients from \"unconditional model\" (model 4.4)\nest4.4 <- coef(mod4.4)$id\nnames(est4.4) <- c('b0_uncond', 'b1_uncond') #rename\nest4.4$id = rownames( est4.4 )\n\n## Extract site-specific coefficients from the \"conditional model\" (model 4.5)\nest4.5 <- coef(mod4.5)$id\nhead( est4.5 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     (Intercept)  meanses   sector ses_grpcenter meanses:ses_grpcenter\n1224    12.02263 5.332898 1.226453      2.933689              1.038918\n1288    12.55180 5.332898 1.226453      2.979174              1.038918\n1296    10.38509 5.332898 1.226453      2.744066              1.038918\n1308    12.12710 5.332898 1.226453      2.923822              1.038918\n1317    10.56530 5.332898 1.226453      2.806582              1.038918\n1358    11.60500 5.332898 1.226453      2.961265              1.038918\n     sector:ses_grpcenter\n1224            -1.642619\n1288            -1.642619\n1296            -1.642619\n1308            -1.642619\n1317            -1.642619\n1358            -1.642619\n```\n:::\n\n```{.r .cell-code}\nest4.5$id = rownames( est4.5 )\n\n# Now we need to calculate the point estimates using our individual regression equations\n# including our level-2 values for each school\n# (This is a bit of a pain.)\nest4.5 = merge( est4.5, mod.comp, by=\"id\", suffixes = c( \"\", \".v\" ) )\nhead( est4.5 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    id (Intercept)  meanses   sector ses_grpcenter meanses:ses_grpcenter\n1 1224    12.02263 5.332898 1.226453      2.933689              1.038918\n2 1288    12.55180 5.332898 1.226453      2.979174              1.038918\n3 1296    10.38509 5.332898 1.226453      2.744066              1.038918\n4 1308    12.12710 5.332898 1.226453      2.923822              1.038918\n5 1317    10.56530 5.332898 1.226453      2.806582              1.038918\n6 1358    11.60500 5.332898 1.226453      2.961265              1.038918\n  sector:ses_grpcenter meanses.v sector.v n_j    b0_ols    b1_ols se_b0_ols\n1            -1.642619    -0.428        0  47  9.715447 2.5085817 1.0954478\n2            -1.642619     0.128        0  25 13.510800 3.2554487 1.3637656\n3            -1.642619    -0.420        0  48  7.635958 1.0759591 0.7740752\n4            -1.642619     0.534        1  20 16.255500 0.1260242 1.4045813\n5            -1.642619     0.351        1  48 13.177688 1.2739128 0.7902486\n6            -1.642619    -0.014        0  30 11.206233 5.0680087 0.8994345\n  se_b1_ols\n1  1.765216\n2  2.079675\n3  1.209016\n4  3.003437\n5  1.435942\n6  1.391550\n```\n:::\n\n```{.r .cell-code}\nest4.5 = mutate( est4.5, \n                 b0_cond = `(Intercept)` + sector * sector.v + meanses * meanses.v,\n                 b1_cond = ses_grpcenter + `sector:ses_grpcenter` * sector.v + `meanses:ses_grpcenter` * meanses.v )\n\nest4.5 = dplyr::select( est4.5, id, b0_cond, b1_cond )\n\n\n## Combine the MLM estimates into 1 dataset with ids\nest.mlm <- merge( est4.4, est4.5, by=\"id\" )\n\n# Merge all the estimates together by school id\nmod.comp <- merge(mod.comp,est.mlm,by = 'id',all=TRUE)\n\nhead( mod.comp )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    id meanses sector n_j    b0_ols    b1_ols se_b0_ols se_b1_ols b0_uncond\n1 1224  -0.428      0  47  9.715447 2.5085817 1.0954478  1.765216  9.956953\n2 1288   0.128      0  25 13.510800 3.2554487 1.3637656  2.079675 13.386036\n3 1296  -0.420      0  48  7.635958 1.0759591 0.7740752  1.209016  8.039091\n4 1308   0.534      1  20 16.255500 0.1260242 1.4045813  3.003437 15.622073\n5 1317   0.351      1  48 13.177688 1.2739128 0.7902486  1.435942 13.132771\n6 1358  -0.014      0  30 11.206233 5.0680087 0.8994345  1.391550 11.387452\n  b1_uncond   b0_cond  b1_cond\n1  2.262837  9.740146 2.489033\n2  2.375964 13.234409 3.112156\n3  1.872247  8.145275 2.307720\n4  2.050193 16.201317 1.835985\n5  1.997129 13.663596 1.528623\n6  2.738390 11.530341 2.946721\n```\n:::\n:::\n\n\n\n## Table 4.6 Comparing site-specific estimates from different models\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Create the list of rows that B&R include in the table p. 87\nkeeprows <- c(4, 15, 17, 22, 27, 53, 69, 75, 81, 90, 135, 153)\n\n## Limit data to the rows of interest, and print the columns in Table 4.6 in the correct order\ntab4.6 <- mod.comp[keeprows, c('b0_ols','b1_ols','b0_uncond','b1_uncond','b0_cond','b1_cond','n_j','meanses','sector') ]\n\n\n## Print Table 4.6 -- the Empirical Bayes from conditional model (b0_cond, b1_cond) are waaaaaay off\nround(tab4.6,2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    b0_ols b1_ols b0_uncond b1_uncond b0_cond b1_cond n_j meanses sector\n4    16.26   0.13     15.62      2.05   16.20    1.84  20    0.53      1\n15   15.98   2.15     15.74      2.19   16.01    1.84  53    0.52      1\n17   18.11   0.09     17.41      1.95   17.25    3.71  29    0.69      0\n22   11.14  -0.78     11.22      1.15   10.89    0.63  67   -0.62      1\n27   13.40   4.10     13.32      2.54   12.95    3.00  38   -0.06      0\n53    9.52   3.74      9.76      2.75    9.37    2.42  51   -0.64      0\n69   11.47   6.18     11.64      2.72   11.92    3.03  25    0.08      0\n75    9.06   1.65      9.28      2.01    9.30    0.67  63   -0.59      1\n81   15.42   5.26     15.25      3.14   15.53    1.91  66    0.43      1\n90   12.14   1.97     12.18      2.14   12.34    3.03  50    0.19      0\n135   4.55   0.25      6.42      1.92    8.55    2.63  14    0.03      0\n153  10.28   0.76     10.71      2.06    9.67    2.37  19   -0.59      0\n```\n:::\n:::\n\n\n\n## Figure 4.2 : Scatter plots of the estimates from 2 unconstrained models\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Panel (a) and Panel (b) are plotted on the same graph \nggplot(data=mod.comp,aes()) + \n  geom_point(aes(x=b1_ols,y=b0_ols),color='black',alpha=0.7) + \n  geom_point(aes(x=b1_uncond,y=b0_uncond),color='blue',alpha=0.7) + \n  labs(title=\"Black=OLS; Blue=Unconditional EB\") +\n  xlim(-5,8) + ylim(2,20)\n```\n\n::: {.cell-output-display}\n![](hsb_ex_files/figure-pdf/unnamed-chunk-12-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Figure 4.3 : Scatter plots of residuals from the OLS & Constrained MLM model\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Luke: Equation 4.271 and 4.27b (p. 92) are allegedly how we calculate the intercept and slope residuals \n## But I'm not sure where the estimates for the gamma-hat terms come from; the OLS model only includes\n## individual-level ses\n\n# trying it here with the predictions from conditional EB\nfes = fixef( mod4.5 )\nfes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          (Intercept)               meanses                sector \n            12.095997              5.332898              1.226453 \n        ses_grpcenter meanses:ses_grpcenter  sector:ses_grpcenter \n             2.938785              1.038918             -1.642619 \n```\n:::\n\n```{.r .cell-code}\nmod.comp = mutate( mod.comp,\n                   u0_ols = b0_ols - (fes[1] + fes[2]*meanses + fes[3]*sector),\n                   u1_ols = b1_ols - (fes[4] + fes[5]*meanses + fes[6]*sector)  )\n\n\n## Panel (a) and (b) plotted on same graph\n\nmod.comp = mutate( mod.comp, \n                   u0_cond = b0_cond - (fes[1] + fes[2]*meanses + fes[3]*sector),\n                   u1_cond = b1_cond - (fes[4] + fes[5]*meanses + fes[6]*sector)  )\n\nhead( mod.comp )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    id meanses sector n_j    b0_ols    b1_ols se_b0_ols se_b1_ols b0_uncond\n1 1224  -0.428      0  47  9.715447 2.5085817 1.0954478  1.765216  9.956953\n2 1288   0.128      0  25 13.510800 3.2554487 1.3637656  2.079675 13.386036\n3 1296  -0.420      0  48  7.635958 1.0759591 0.7740752  1.209016  8.039091\n4 1308   0.534      1  20 16.255500 0.1260242 1.4045813  3.003437 15.622073\n5 1317   0.351      1  48 13.177688 1.2739128 0.7902486  1.435942 13.132771\n6 1358  -0.014      0  30 11.206233 5.0680087 0.8994345  1.391550 11.387452\n  b1_uncond   b0_cond  b1_cond      u0_ols      u1_ols     u0_cond      u1_cond\n1  2.262837  9.740146 2.489033 -0.09807014  0.01445354 -0.07337107 -0.005095579\n2  2.375964 13.234409 3.112156  0.73219201  0.18368221  0.45580075  0.040389349\n3  1.872247  8.145275 2.307720 -2.22022179 -1.42648036 -1.71090544 -0.194719195\n4  2.050193 16.201317 1.835985  0.08528223 -1.72492410  0.03109939 -0.014963432\n5  1.997129 13.663596 1.528623 -2.01661001 -0.38691354 -1.53070178 -0.132203128\n6  2.738390 11.530341 2.946721 -0.81510320  2.14376861 -0.49099553  0.022480378\n```\n:::\n\n```{.r .cell-code}\nnrow( mod.comp )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 160\n```\n:::\n\n```{.r .cell-code}\nggplot(data=mod.comp, aes( pch=as.factor(sector)) ) + \n         geom_point(aes(x=u1_ols, y=u0_ols),color='black', alpha=0.7) +   \n         geom_point(aes(x=u1_cond, y=u0_cond),color='blue', alpha=0.7) + \n         labs(title = \"Black: OLS, Blue: Conditional EB\") + \n         xlim(-6,6) + ylim(-8,8)\n```\n\n::: {.cell-output-display}\n![](hsb_ex_files/figure-pdf/unnamed-chunk-13-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# To get in two-panel format we need to get our data to long format\nmod.comp.ols = data.frame( sector = mod.comp$sector,\n                           u0 = mod.comp$u0_ols,\n                           u1 = mod.comp$u1_ols )\nmod.comp.EB = data.frame(  sector = mod.comp$sector,\n                           u0 = mod.comp$u0_cond,\n                           u1 = mod.comp$u1_cond )\nmod.comp.l = bind_rows( ols=mod.comp.ols, cond = mod.comp.EB, .id = \"method\" )\n\nggplot(data=mod.comp.l, aes( u1, u0, pch=as.factor(sector)) ) + \n  facet_wrap( ~ method ) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](hsb_ex_files/figure-pdf/unnamed-chunk-13-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Table 4.7 : pg 94\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This section is not very good--I would skip.\n# Generating confidence intervals for individual random intercepts and slopes is a weird business.\n\n# OLS First:\n\n# Doing it by fitting OLS on our subset\nsch.2305 = filter( dat, id == 2305 )\nhead( sch.2305 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 13\n# Groups:   id [1]\n  id    minority female    ses mathach  size sector pracad disclim himinty\n  <chr>    <dbl>  <dbl>  <dbl>   <dbl> <dbl>  <dbl>  <dbl>   <dbl>   <dbl>\n1 2305         1      1 -0.738   16.4    485      1   0.69   -1.38       1\n2 2305         1      1 -1.18    12.8    485      1   0.69   -1.38       1\n3 2305         1      1 -0.308   15.3    485      1   0.69   -1.38       1\n4 2305         1      1 -0.358   12.7    485      1   0.69   -1.38       1\n5 2305         1      1 -1.52    10.2    485      1   0.69   -1.38       1\n6 2305         1      1 -0.518    8.94   485      1   0.69   -1.38       1\n# i 3 more variables: meanses <dbl>, ses_grpcenter <dbl>, ses_centered <dbl>\n```\n:::\n\n```{.r .cell-code}\nM.2305 = lm( mathach ~ ses_grpcenter, data=sch.2305 )\nM.2305\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = mathach ~ ses_grpcenter, data = sch.2305)\n\nCoefficients:\n  (Intercept)  ses_grpcenter  \n      11.1378        -0.7821  \n```\n:::\n\n```{.r .cell-code}\nconfint( M.2305 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  2.5 %    97.5 %\n(Intercept)    9.911824 12.363698\nses_grpcenter -2.665989  1.101767\n```\n:::\n\n```{.r .cell-code}\nsch.8367 = filter( dat, id == 8367 )\nhead( sch.8367 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 13\n# Groups:   id [1]\n  id    minority female    ses mathach  size sector pracad disclim himinty\n  <chr>    <dbl>  <dbl>  <dbl>   <dbl> <dbl>  <dbl>  <dbl>   <dbl>   <dbl>\n1 8367         0      0 -0.228  15.9     153      0      0    1.79       0\n2 8367         0      1 -0.208   1.86    153      0      0    1.79       0\n3 8367         1      0  0.532  -2.83    153      0      0    1.79       0\n4 8367         0      1  0.662   2.12    153      0      0    1.79       0\n5 8367         0      0 -0.228   6.76    153      0      0    1.79       0\n6 8367         0      0 -1.08    0.725   153      0      0    1.79       0\n# i 3 more variables: meanses <dbl>, ses_grpcenter <dbl>, ses_centered <dbl>\n```\n:::\n\n```{.r .cell-code}\nM.8367 = lm( mathach ~ ses_grpcenter, data=sch.8367 )\nM.8367\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = mathach ~ ses_grpcenter, data = sch.8367)\n\nCoefficients:\n  (Intercept)  ses_grpcenter  \n       4.5528         0.2504  \n```\n:::\n\n```{.r .cell-code}\nconfint( M.8367 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  2.5 %   97.5 %\n(Intercept)    1.872974 7.232598\nses_grpcenter -3.431096 3.931845\n```\n:::\n\n```{.r .cell-code}\n# Use SE from earlier to get confint\nest4.7 <- mod.comp[c(22,135),]\nest4.7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      id meanses sector n_j    b0_ols     b1_ols se_b0_ols se_b1_ols b0_uncond\n22  2305  -0.622      1  67 11.137761 -0.7821112 0.6138468  0.943289 11.222551\n135 8367   0.032      0  14  4.552786  0.2503748 1.2299413  1.689668  6.423938\n    b1_uncond   b0_cond   b1_cond    u0_ols    u1_ols    u0_cond     u1_cond\n22   1.149555 10.886600 0.6276417  1.132373 -1.432070  0.8812116 -0.02231763\n135  1.924903  8.549007 2.6307047 -7.713864 -2.721656 -3.7176433 -0.34132569\n```\n:::\n\n```{.r .cell-code}\n# CI for intercept and slope using our normal and stored SEs.\n# (Not taking t distribution into account changes things, as does not\n# taking the uncertainty in the fixed effects for the EB CIs.  So this is\n# very approximate.)\nse_uncond = as.data.frame( se.coef(mod4.4)$id )\nhead( se_uncond )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     (Intercept) ses_grpcenter\n1224   0.8464092     0.7189592\n1288   1.1205609     0.7593421\n1296   0.8382669     0.7111100\n1308   1.2307722     0.8005012\n1317   0.8382675     0.7377054\n1358   1.0354852     0.7489241\n```\n:::\n\n```{.r .cell-code}\nnames( se_uncond ) = c(\"se_b0_uncond\",\"se_b1_uncond\" )\nse_cond = as.data.frame( se.coef(  mod4.5 )$id )\nnames( se_cond ) = c(\"se_b0_cond\",\"se_b1_cond\" )\nhead( se_cond )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     se_b0_cond se_b1_cond\n1224  0.7662313  0.2929654\n1288  0.9521965  0.2988437\n1296  0.7601221  0.2923332\n1308  1.0176181  0.3025414\n1317  0.7603073  0.2940970\n1358  0.8982481  0.2971694\n```\n:::\n\n```{.r .cell-code}\nse_uncond$id = rownames( se_uncond )\nse_cond$id = rownames( se_cond )\nest4.7 = merge( est4.7, se_uncond, by=\"id\" )\nest4.7 = merge( est4.7, se_cond, by=\"id\" )\n\nest4.7.int = mutate( est4.7, \n                 CI.low.ols = b0_ols + - 1.96 * se_b0_ols,\n                 CI.high.ols = b0_ols + 1.96 * se_b0_ols,\n                 CI.low.uncond = b0_uncond + - 1.96 * se_b0_uncond,\n                 CI.high.uncond = b0_uncond + 1.96 * se_b0_uncond,\n                 CI.low.cond = b0_cond + - 1.96 * se_b0_cond,\n                 CI.high.cond = b0_cond + 1.96 * se_b0_cond )\n\ndplyr::select( est4.7.int, starts_with(\"CI\" ) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  CI.low.ols CI.high.ols CI.low.uncond CI.high.uncond CI.low.cond CI.high.cond\n1   9.934621   12.340901      9.815648      12.629455    9.579800     12.19340\n2   2.142101    6.963471      3.642797       9.205078    6.361492     10.73652\n```\n:::\n\n```{.r .cell-code}\nest4.7.slope = mutate( est4.7, \n                     CI.low.ols = b1_ols + - 1.96 * se_b1_ols,\n                     CI.high.ols = b1_ols + 1.96 * se_b1_ols,\n                     CI.low.uncond = b1_uncond + - 1.96 * se_b1_uncond,\n                     CI.high.uncond = b1_uncond + 1.96 * se_b1_uncond,\n                     CI.low.cond = b1_cond + - 1.96 * se_b1_cond,\n                     CI.high.cond = b1_cond + 1.96 * se_b1_cond )\n\ndplyr::select( est4.7.slope, starts_with(\"CI\" ) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  CI.low.ols CI.high.ols CI.low.uncond CI.high.uncond CI.low.cond CI.high.cond\n1  -2.630958    1.066735    -0.1675367       2.466647   0.0629627     1.192321\n2  -3.061375    3.562124     0.3960110       3.453795   2.0356645     3.225745\n```\n:::\n:::\n",
    "supporting": [
      "hsb_ex_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}