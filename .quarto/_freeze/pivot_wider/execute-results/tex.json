{
  "hash": "e431d60a580515d4d12e4c44b0507b3c",
  "result": {
    "markdown": "---\ntitle: \"`pivot_longer` and `pivot_wider`\"\nauthor: \"Luke Miratrix and Josh Gilbert\"\neditor: \n  markdown: \n    wrap: sentence\n---\n\n\n\n\n\nGenerally, you want your data to be in a form where each row is a case and each column is a variable (either explanatory or response).\nSometimes your data don't start that way.\nThis section describes how to move your data around to get it in that form.\nThe tidyverse provides a simple method for doing this (`pivot_longer()` and `pivot_wider()`) which you should read about in R for Data Science.\nThere are also \"old school\" ways of doing this, via a method called `reshape()`; this way is more powerful and useful in some circumstances.\nSee the final section for more on this old-style approach.\n\nBut for now, the pivot methods will pretty much do everything you want.\nBoth `pivot_longer` and `pivot_wider` from `tidyverse` are great functions to understand.\nFirst, we load `tidyverse` and make some fake data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\ndat <- data.frame( ID = c( 1:3 ), \n                  X = c( 10, 20, 30 ),\n                  Y1 = 1:3,\n                  Y2 = 10 + 1:3,\n                  Y3 = 20 + 1:3 )\n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  ID  X Y1 Y2 Y3\n1  1 10  1 11 21\n2  2 20  2 12 22\n3  3 30  3 13 23\n```\n:::\n:::\n\n\n\nThis data is in wide format, where we have multiple measurements (Y1, Y2, and Y3) for each individual (each row of data).\nWe use `pivot_longer` to take our `Y` values and nest them within each `ID` for longitudinal MLM analysis.\n(NB you can use SEM to fit longitudinal models with wide data; we do not explore that application here.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatL <- pivot_longer(dat, Y1:Y3, \n                     names_to = \"time\", \n                     values_to = \"front\" )\n\ndatL\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 x 4\n     ID     X time  front\n  <int> <dbl> <chr> <dbl>\n1     1    10 Y1        1\n2     1    10 Y2       11\n3     1    10 Y3       21\n4     2    20 Y1        2\n5     2    20 Y2       12\n6     2    20 Y3       22\n7     3    30 Y1        3\n8     3    30 Y2       13\n9     3    30 Y3       23\n```\n:::\n:::\n\n\n\n`pivot_wider` takes us back in the other direction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnewdat <- pivot_wider( datL, c(ID, X), \n                       names_from=time, \n                       values_from=front  )\n\nnewdat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 5\n     ID     X    Y1    Y2    Y3\n  <int> <dbl> <dbl> <dbl> <dbl>\n1     1    10     1    11    21\n2     2    20     2    12    22\n3     3    30     3    13    23\n```\n:::\n:::\n\n\n\nWe then verify our work with a few checks.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot( length( unique( newdat$ID ) ) == nrow( newdat ) )\n\nstudents = datL %>% dplyr::select( ID, X ) %>%\n    unique()\nstudents\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n     ID     X\n  <int> <dbl>\n1     1    10\n2     2    20\n3     3    30\n```\n:::\n\n```{.r .cell-code}\nstudents = merge( students, newdat, by=\"ID\" )\n```\n:::\n\n\n\n\n## Optional: Using old School `reshape`\n\nSay you have data in a form where a row has a value for a variable for several different points in time.\nThe following code turns it into a data.frame where each row (case) is a value for the variable at that point in time.\nYou also have an ID variable for which Country the GDP came from.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndtw = read.csv( \"data/fake_country_block.csv\", as.is=TRUE )\ndtw\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Country X1997 X1998 X1999 X2000 X2001 X2002 X2003 X2004\n1   China   0.5     1     2   3.4     4   5.3   6.0     7\n2 Morocco  31.9    32    33  34.0    NA  36.0  37.0    NA\n3 England  51.3    52    53  54.3    55  56.0  57.3    58\n```\n:::\n:::\n\n\n\nHere we have three rows, but actually a lot of cases if we consider each time point a case.\nFor trying it on your own, get the sample csv file ()\\[here\\]\\\nSee the website to get the sample csv file \\verb\\|fake_country_block.csv\\|.\n\nThe following \\emph{reshapes} our original data by making a case for each time point:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt = reshape( dtw, idvar=\"Country\", timevar=\"Year\", varying=2:9, sep=\"\", direction=\"long\" )\nhead(dt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Country Year    X\nChina.1997     China 1997  0.5\nMorocco.1997 Morocco 1997 31.9\nEngland.1997 England 1997 51.3\nChina.1998     China 1998  1.0\nMorocco.1998 Morocco 1998 32.0\nEngland.1998 England 1998 52.0\n```\n:::\n:::\n\n\n\nThings to notice: each case has a \"row name\" made out of the country and the Year.\nThe \"2:9\" indicates a range of columns for the variable that is actually the same variable.\\\nR picked up that, for each of these columns, \"X\" is the name of the variable and the number is the time, and seperated them.\nYou can set the name of your time variable, \\verb\\|timevar\\|, to whatever you want.\n\nThe above output is called \"long format\" and the prior is called \"wide format.\"\\\nYou can go in either direction.\nHere:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndtn = reshape( dt, idvar=\"Country\", timevar=\"Year\" )\ndtn\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Country X.1997 X.1998 X.1999 X.2000 X.2001 X.2002 X.2003 X.2004\nChina.1997     China    0.5      1      2    3.4      4    5.3    6.0      7\nMorocco.1997 Morocco   31.9     32     33   34.0     NA   36.0   37.0     NA\nEngland.1997 England   51.3     52     53   54.3     55   56.0   57.3     58\n```\n:::\n:::\n\n\n\nYou can reshape on multiple variables.\nFor example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexp.dat = data.frame( ID=c(\"a\",\"b\",\"c\",\"d\"), \n      cond = c(\"AI\",\"DI\",\"DI\",\"AI\"),\n\t\t\ttrial1 = c(\"E\",\"U\",\"U\",\"E\"),\n\t\t\tdec1 = c(1,1,0,1),\n\t\t\ttrial2 = c(\"U\",\"E\",\"U\",\"E\"),\n\t\t\tdec2 = c(0,0,0,1),\n\t\t\t\ttrial3 = c(\"U\",\"E\",\"E\",\"U\"),\n\t\t\tdec3 = c(0,1,0,1),\n\t\t\t\ttrial4 = c(\"E\",\"U\",\"E\",\"U\"),\n\t\t\tdec4 = c(0,1,0,0) )\nexp.dat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  ID cond trial1 dec1 trial2 dec2 trial3 dec3 trial4 dec4\n1  a   AI      E    1      U    0      U    0      E    0\n2  b   DI      U    1      E    0      E    1      U    1\n3  c   DI      U    0      U    0      E    0      E    0\n4  d   AI      E    1      E    1      U    1      U    0\n```\n:::\n\n```{.r .cell-code}\nrs = reshape( exp.dat,  idvar=\"ID\", \n  \t\tvarying=c( 3:10 ), sep=\"\", direction=\"long\")\t\t\t\nhead(rs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    ID cond time trial dec\na.1  a   AI    1     E   1\nb.1  b   DI    1     U   1\nc.1  c   DI    1     U   0\nd.1  d   AI    1     E   1\na.2  a   AI    2     U   0\nb.2  b   DI    2     E   0\n```\n:::\n:::\n\n\n\nIt sorts out which variables are which.\nNote the names have to be exactly the same for any group of variables.\n\nOnce you have reshaped, you can look at things more easily (I use mosaic's tally instead of the base table):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmosaic::tally( trial ~ dec, data=rs )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     dec\ntrial 0 1\n    E 4 4\n    U 5 3\n```\n:::\n:::\n\n\n\nor\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmosaic::tally( trial~dec+cond, data=rs )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , cond = AI\n\n     dec\ntrial 0 1\n    E 1 3\n    U 3 1\n\n, , cond = DI\n\n     dec\ntrial 0 1\n    E 3 1\n    U 2 2\n```\n:::\n:::\n\n\n\n### \n",
    "supporting": [
      "pivot_wider_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}