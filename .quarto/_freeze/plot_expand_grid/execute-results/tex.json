{
  "hash": "3b89707db33bd9defccb02f6beebd301",
  "result": {
    "markdown": "---\ntitle: \"Example of making plots with `expand.grid`\"\nauthor: \"Luke Miratrix\"\neditor: \n  markdown: \n    wrap: sentence\n---\n\n\n\n\n\n## Introduction\n\nThis script demonstrates using the `predict()` function to make plots with separate lines for different groups.\nA core element is the `expand.grid()` method.\nThe central idea is this: for each of our groups we manually create a series of points at different levels of our covariate (e.g. ses or time) and then predict the outcome for each of these values.\nWe then plot these predicted points, and it makes a smooth curve for that group.\n\nIn this document we start with clustered data (the HS&B dataset) and then illustrate how to this with longitudinal data as well.\n\n## Making plots for the HS&B Dataset\n\nIn this section we first look at how to plot the model results by making a tiny dataset from the fixed effects, and then we extend to more powerful plotting of individual schools.\n\n### Setting up the HS&B data\n\n\n\n\n\n\n\nThe \"many small worlds\" view says each school has its own regression line.\nWe are going to plot them all.\nSee the lecture code files for how to load the HS&B dataset.\nFor clarity it is omitted from the printout.\nWe end up with this for the schools:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead( sdat )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    id size   sector meanses\n1 1224  842   public  -0.428\n2 1288 1855   public   0.128\n3 1296 1719   public  -0.420\n4 1308  716 catholic   0.534\n5 1317  455 catholic   0.351\n6 1358 1430   public  -0.014\n```\n:::\n:::\n\n\n\nand this for students (we merged in the school info already):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead( dat )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    id minority female    ses mathach size sector meanses\n1 1224        0      1 -1.528   5.876  842 public  -0.428\n2 1224        0      1 -0.588  19.708  842 public  -0.428\n3 1224        0      0 -0.528  20.349  842 public  -0.428\n4 1224        0      0 -0.668   8.781  842 public  -0.428\n5 1224        0      0 -0.158  17.898  842 public  -0.428\n6 1224        0      0  0.022   4.583  842 public  -0.428\n```\n:::\n:::\n\n\n\nWe fit a fancy random slopes model with 2nd level covariates that impact both the overall school means and the ses by math achievment slopes.\nOur model is $$\n\\begin{aligned}\ny_{ij} &= \\beta_{0j} + \\beta_{1j} ses_{ij} +  \\epsilon_{ij} \\\\\n\\beta_{0j} &= \\gamma_{00} + \\gamma_{01} sector_j + u_{0j} \\\\\n\\beta_{1j} &= \\gamma_{10} + \\gamma_{11} sector_j + u_{1j} \n\\end{aligned}\n$$ We omit the equations for the random effect distributions.\nThe $\\epsilon_{ij}$ are normal, and the $(u_{0j},u_{1j})$ are bivariate normal, as usual.\nWe fit the model as so:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM1 = lmer( mathach ~ 1 + ses*sector + (1 + ses|id), data=dat )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in checkConv(attr(opt, \"derivs\"), opt$par, ctrl = control$checkConv, :\nModel failed to converge with max|grad| = 0.00578929 (tol = 0.002, component 1)\n```\n:::\n\n```{.r .cell-code}\ndisplay( M1 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlmer(formula = mathach ~ 1 + ses * sector + (1 + ses | id), data = dat)\n                   coef.est coef.se\n(Intercept)        11.75     0.23  \nses                 2.96     0.14  \nsectorcatholic      2.13     0.35  \nses:sectorcatholic -1.31     0.22  \n\nError terms:\n Groups   Name        Std.Dev. Corr \n id       (Intercept) 1.95          \n          ses         0.28     1.00 \n Residual             6.07          \n---\nnumber of obs: 7185, groups: id, 160\nAIC = 46585.1, DIC = 46557.2\ndeviance = 46563.2 \n```\n:::\n:::\n\n\n\n### Plotting the model results\n\nWe can plot the model results by making a little dataset by hand.\nThis section of the handout illustrates how you can hand-construct plots by directly calculating predicted values from your model.\nThis is a very useful skill, and we recommend studying this area of the handout as a way of learning how to control plotting at a very direct level.\n\nSo, to continue, we proceed in three steps.\n\n*Step 1: Decide on the plot.* Let's make a plot of outcome vs. ses with two lines (one for catholic and one for public).\nSometimes it is worth actually sketching the desired plot on scratch paper, identifying the x and y axes and general lines desired.\n\n*Step 2: calculate some outcomes using our model.* We do this by deciding what values we want to plot, and then making the outcome.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquantile( dat$ses, c( 0.05, 0.95 ) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    5%    95% \n-1.318  1.212 \n```\n:::\n\n```{.r .cell-code}\nplt = data.frame( ses = c(-1.5, 1.25, -1.5, 1.25 ),\n                  catholic = c( 0, 0, 1, 1 ) )\ncf = fixef( M1 )\ncf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       (Intercept)                ses     sectorcatholic ses:sectorcatholic \n         11.751789           2.957538           2.129531          -1.313363 \n```\n:::\n\n```{.r .cell-code}\nplt = mutate( plt,\n              Y = cf[[1]] + cf[[2]]*ses + cf[[3]]*catholic + cf[[4]]*ses*catholic )\nplt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    ses catholic         Y\n1 -1.50        0  7.315482\n2  1.25        0 15.448711\n3 -1.50        1 11.415057\n4  1.25        1 15.936538\n```\n:::\n:::\n\n\n\nNote that we have made a little mini-dataset with just the points we want to put on our plot.\nWe calculated these points \"by hand\".\nThere is no shame in this.\n\n*Step 3: plot.* We plot using ggplot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplt$catholic = factor( plt$catholic, \n                       labels=c(\"public\",\"catholic\"),\n                       levels=c(0,1) )\nggplot( plt, aes( ses, Y, col=catholic ) ) +\n    geom_line()\n```\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-6-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n#### A fancy diversion: categorical variables on the $x$-axis\n\nSay we decided to fit a model where we have ses **categories**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat$ses.cat = cut( dat$ses, \n                   breaks=quantile( dat$ses, c( 0, 0.33, 0.67, 1 ) ),\n                   labels = c( \"low\",\"mid\",\"high\"),\n                   include.lowest = TRUE )\ntable( dat$ses.cat )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n low  mid high \n2371 2462 2352 \n```\n:::\n\n```{.r .cell-code}\nM1b = lmer( mathach ~ 1 + ses.cat*sector + (1 + ses|id), data=dat )\ndisplay( M1b )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlmer(formula = mathach ~ 1 + ses.cat * sector + (1 + ses | id), \n    data = dat)\n                           coef.est coef.se\n(Intercept)                 9.19     0.27  \nses.catmid                  2.28     0.25  \nses.cathigh                 5.07     0.29  \nsectorcatholic              3.44     0.42  \nses.catmid:sectorcatholic  -0.98     0.38  \nses.cathigh:sectorcatholic -2.47     0.42  \n\nError terms:\n Groups   Name        Std.Dev. Corr \n id       (Intercept) 2.05          \n          ses         0.47     0.23 \n Residual             6.10          \n---\nnumber of obs: 7185, groups: id, 160\nAIC = 46691.5, DIC = 46660.7\ndeviance = 46666.1 \n```\n:::\n:::\n\n\n\nMake our outcomes:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplt = data.frame( ses.mid = c( 0, 1, 0, 0, 1, 0 ),\n                  ses.high = c( 0, 0, 1, 0, 0, 1 ),\n                  catholic = c( 0, 0, 0, 1, 1, 1 ) )\ncf = fixef( M1b )\ncf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               (Intercept)                 ses.catmid \n                 9.1915044                  2.2808807 \n               ses.cathigh             sectorcatholic \n                 5.0721921                  3.4398984 \n ses.catmid:sectorcatholic ses.cathigh:sectorcatholic \n                -0.9759927                 -2.4707460 \n```\n:::\n\n```{.r .cell-code}\nplt = mutate( plt,\n              Y = cf[[1]] + cf[[2]]*ses.mid + cf[[3]]*ses.high +\n                cf[[4]]*catholic + cf[[5]]*ses.mid*catholic + cf[[6]]*ses.high*catholic )\nplt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  ses.mid ses.high catholic         Y\n1       0        0        0  9.191504\n2       1        0        0 11.472385\n3       0        1        0 14.263697\n4       0        0        1 12.631403\n5       1        0        1 13.936291\n6       0        1        1 15.232849\n```\n:::\n:::\n\n\n\nAnd plot\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplt$catholic = factor( plt$catholic, \n                       labels=c(\"public\",\"catholic\"),\n                       levels=c(0,1) )\nplt$ses = \"low\"\nplt$ses[plt$ses.mid==1] = \"mid\"\nplt$ses[plt$ses.high==1] = \"high\"\nplt$ses = factor( plt$ses, levels=c(\"low\",\"mid\",\"high\") )\nggplot( plt, aes( ses, Y, col=catholic, group=catholic ) ) +\n    geom_line() + geom_point()\n```\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-9-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nNote the *very important* `group=catholic` line that tells the plot to group everyone by catholic.\nIf not, it will get confused and note that since ses is categorical, try to group on that.\nThen it cannot make a line since each group has only a single point.\n\n### Plotting individual school regression lines\n\nWe can plot the individual lines by hand-calculating the school level slopes and intercepts.\nThis code shows how:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoefs = coef( M1 )$id\nhead( coefs )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     (Intercept)      ses sectorcatholic ses:sectorcatholic\n1224   11.084408 2.863501       2.129531          -1.313363\n1288   12.761032 3.099743       2.129531          -1.313363\n1296    9.193415 2.597052       2.129531          -1.313363\n1308   12.709882 3.092535       2.129531          -1.313363\n1317   10.719013 2.812016       2.129531          -1.313363\n1358   11.478455 2.919031       2.129531          -1.313363\n```\n:::\n\n```{.r .cell-code}\ncoefs = rename( coefs, \n                gamma.00 = `(Intercept)`,\n                gamma.10 = `ses`,\n                gamma.01 = `sectorcatholic`,\n                gamma.11 = `ses:sectorcatholic` )\ncoefs$id = rownames( coefs )\ncoefs = merge( coefs, sdat, by=\"id\" )\ncoefs = mutate( coefs,\n                beta.0 = gamma.00 + gamma.01 * (sector==\"catholic\"),\n                beta.1 = gamma.10 + gamma.11 * (sector==\"catholic\") )\n```\n:::\n\n\n\nNote how we have to add up our gammas to get our betas for each school.\nSee our final betas, one set for each school:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead( dplyr::select( coefs, -gamma.00, -gamma.10, -gamma.01, -gamma.11 ) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    id size   sector meanses    beta.0   beta.1\n1 1224  842   public  -0.428 11.084408 2.863501\n2 1288 1855   public   0.128 12.761032 3.099743\n3 1296 1719   public  -0.420  9.193415 2.597052\n4 1308  716 catholic   0.534 14.839413 1.779172\n5 1317  455 catholic   0.351 12.848543 1.498653\n6 1358 1430   public  -0.014 11.478455 2.919031\n```\n:::\n:::\n\n\n\nNow let's plot a subsample of 20 schools\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed( 102030 )\nsub20 = sample( unique( dat$id ), 20 )\n\ncoefs.20 = filter( coefs, id %in% sub20 )\n\nggplot( coefs.20, aes( group=id ) ) +\n  geom_abline( aes( slope=beta.1, intercept=beta.0, col=sector) ) +\n  coord_cartesian( xlim=c(-2.5,2), ylim=range(dat$mathach) )\n```\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-12-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n*Commentary:* We need to specify the size of the plot since we have no data, just the intercepts and slopes.\nWe are using the Emperical Bayes estimates of the random effects added to our school level fixed effects to get the $\\hat{\\beta}_{0j}, \\hat{\\beta}_{1j}$ which define the school-specific regression line for school $j$.\n\nOur two types of school are clearly separated.\nCatholic schools have higher average performance, and less of a ses-achievement relationship.\nSince we have merged in our school level data, we can color the lines by catholic vs public, making our plot easier to read.\n\n### Plotting with predict()\n\nA more general plotitng approach is to plot using `predict()`, where for each student we predict the outcome.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat$math.hat = predict( M1 )\n```\n:::\n\n\n\nNow let's plot a subsample of 20 schools\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat.20 = filter( dat, id %in% sub20 )\n\nggplot( dat.20, aes( ses, math.hat, group=id, col=sector ) ) +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-14-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nBut look at how the lines don't go the full distance.\nWhat ggplot is doing is plotting the individual students, and connecting them with a line.\nWe can see this by plotting the students as well, like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot( dat.20, aes( ses, math.hat, group=id, col=sector ) ) +\n  geom_line() +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-15-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nWe have a predicted outcome for each student, which removes the student residual, giving just the school trends.\nIf we don't have students for some range of ses for a school, we won't have points in our plot for that range for that school.\nThe lines thus give the ranges (left to right) of the ses values in each school.\n\n### Making our lines go the same length with expand.grid()\n\nThe way we fix this is we, for each school, make a bunch of fake students with different SES and predict along all those fake students.\nThis will give us equally spaced lines.\n\nThat being said: the shorter lines above are also informative, as they give you a sense of what the range of ses for each school actually is.\nWhich approach is somewhat a matter of taste.\n\nWe can generate fake children of each group for each school using `expand.grid()`.\nThis method will generate a dataframe with all combinations of the given variables supplied.\nHere we make all combinations of ses, for a set of ses values, and school id.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsynth.dat = expand_grid( id = unique( dat$id ),\n                         ses = seq( -2.5, 2, length.out=9 ) )\nhead( synth.dat )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 2\n  id       ses\n  <chr>  <dbl>\n1 1224  -2.5  \n2 1224  -1.94 \n3 1224  -1.38 \n4 1224  -0.812\n5 1224  -0.25 \n6 1224   0.312\n```\n:::\n:::\n\n\n\nThe `seq()` command makes an evenly spaced *seq*uence of numbers going from the first to the last, with 9 numbers.\nE.g.,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq( 1, 10, length.out=4 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  4  7 10\n```\n:::\n:::\n\n\n\nWe then merge our school info back in to get sector for each school id:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsynth.dat = merge( synth.dat, sdat, by=\"id\", all.x=TRUE )\n```\n:::\n\n\n\nWe finally predict for each school, predicting outcome for our fake kids in each school.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsynth.dat$math.hat = predict( M1, newdata=synth.dat )\n```\n:::\n\n\n\nWe have predictions just as above, just for students that we set for each school.\nThe school random effects and everything remain because we are using the original school ids.\n\nUsing our new data, plot 20 random schools--this code is the same as in the prior subsection.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsynth.dat.20 = filter( synth.dat, id %in% sub20 )\n\nggplot( synth.dat.20, aes( ses, math.hat, group=id, col=sector ) ) +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-20-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nBut see our equally spaced students?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot( synth.dat.20, aes( ses, math.hat, group=id, col=sector ) ) +\n  geom_line() +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-21-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n**Why do this?** The `predict()` approach allows us to avoid working with the gammas and adding them up like we did above.\nThis is a flexible and powerful approach that avoids a lot of work in many cases.\nIn the next section we illustrate by fitting curves rather than lines.\nThis would be very hard to do directly.\n\n### Superfancy extra bonus plotting of complex models!\n\nWe can use predict for weird nonlinear relationships also.\nThis will be important for longitudinal data.\nTo illustrate we fit a model that allows a quadradic relationship between ses and math achievement.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat$ses2 = dat$ses^2\nM2 = lmer( mathach ~ 1 + (ses + ses2)*sector + meanses + (1 + ses|id), data=dat )\n\ndisplay( M2 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlmer(formula = mathach ~ 1 + (ses + ses2) * sector + meanses + \n    (1 + ses | id), data = dat)\n                    coef.est coef.se\n(Intercept)         12.17     0.21  \nses                  2.79     0.15  \nses2                 0.04     0.13  \nsectorcatholic       1.23     0.33  \nmeanses              3.14     0.38  \nses:sectorcatholic  -1.35     0.22  \nses2:sectorcatholic  0.06     0.21  \n\nError terms:\n Groups   Name        Std.Dev. Corr \n id       (Intercept) 1.53          \n          ses         0.23     0.49 \n Residual             6.07          \n---\nnumber of obs: 7185, groups: id, 160\nAIC = 46539.7, DIC = 46495.9\ndeviance = 46506.8 \n```\n:::\n:::\n\n\n\nTo fit a quadratic model we need our quadratic ses term, which we make by hand.\nWe could also have used `I(ses^2)` in the `lmer()` command directly, but people don't tend to find that easy to read.\n\nAnd here we predict and plot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsynth.dat = expand.grid( id = unique( dat$id ),\n                         ses= seq( -2.5, 2, length.out=9 ) )\nsynth.dat$ses2 = synth.dat$ses^2\nsynth.dat = merge( synth.dat, sdat, by=\"id\", all.x=TRUE )\n```\n:::\n\n\n\nNote how we make our `ses2` variable out of `ses` just like we did above.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsynth.dat$math.hat = predict( M2, newdata=synth.dat )\n\nsynth.dat.20 = filter( synth.dat, id %in% sub20 )\n\nggplot( synth.dat.20, aes( ses, math.hat, group=id, col=sector ) ) +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-24-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nThis code is the same as above.\nThe prediction handles all our model complexity for us.\n\nAgain, we have our equally spaced students:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot( synth.dat.20, aes( ses, math.hat, group=id, col=sector ) ) +\n  geom_line() +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-25-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Longitudinal Data\n\nWe next do the above, but for longitudinal data.\nThe story is basically the same.\n\n### The data\n\nWe use the \"US Sustaining Effects Study\" taken from Raudenbush and Bryk (we have not seen these data in class).\nWe have kids in grades nested in schools.\nSo longitudinal data with a clustering on top of that.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead( dat )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       CHILDID     SCHOOLID YEAR GRADE   MATH FEMALE SIZE RACEETH\n1 101480302    3440         -0.5     1 -1.694      1  588   black\n2 101480302    3440          0.5     2 -0.211      1  588   black\n3 101480302    3440          1.5     3 -0.403      1  588   black\n4 101480302    3440          2.5     4  0.501      1  588   black\n5 173559292    2820         -0.5     1 -0.194      0  678   white\n6 173559292    2820          0.5     2  2.140      0  678   white\n```\n:::\n:::\n\n\n\n### A model\n\nWe will be using the following 3-level quadradic growth model:\n\n\n\n::: {.cell hash='plot_expand_grid_cache/pdf/fitmodel_77fe3b00cc0a7ee118152a8d2aaec570'}\n\n```{.r .cell-code}\nM4 = lmer( MATH ~ 1 + (YEAR + I(YEAR^2)) * (FEMALE * RACEETH ) + \n                (YEAR|CHILDID:SCHOOLID) + (YEAR|SCHOOLID), data=dat )\ndisplay( M4 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlmer(formula = MATH ~ 1 + (YEAR + I(YEAR^2)) * (FEMALE * RACEETH) + \n    (YEAR | CHILDID:SCHOOLID) + (YEAR | SCHOOLID), data = dat)\n                                 coef.est coef.se\n(Intercept)                      -0.90     0.06  \nYEAR                              0.76     0.02  \nI(YEAR^2)                        -0.04     0.01  \nFEMALE                            0.02     0.05  \nRACEETHhispanic                   0.23     0.10  \nRACEETHwhite                      0.79     0.10  \nFEMALE:RACEETHhispanic           -0.01     0.12  \nFEMALE:RACEETHwhite              -0.34     0.12  \nYEAR:FEMALE                       0.01     0.02  \nYEAR:RACEETHhispanic              0.10     0.03  \nYEAR:RACEETHwhite                 0.07     0.03  \nI(YEAR^2):FEMALE                  0.01     0.01  \nI(YEAR^2):RACEETHhispanic        -0.01     0.01  \nI(YEAR^2):RACEETHwhite           -0.02     0.01  \nYEAR:FEMALE:RACEETHhispanic      -0.01     0.04  \nYEAR:FEMALE:RACEETHwhite         -0.02     0.04  \nI(YEAR^2):FEMALE:RACEETHhispanic  0.00     0.02  \nI(YEAR^2):FEMALE:RACEETHwhite     0.02     0.02  \n\nError terms:\n Groups           Name        Std.Dev. Corr \n CHILDID:SCHOOLID (Intercept) 0.79          \n                  YEAR        0.11     0.55 \n SCHOOLID         (Intercept) 0.34          \n                  YEAR        0.10     0.31 \n Residual                     0.54          \n---\nnumber of obs: 7230, groups: CHILDID:SCHOOLID, 1721; SCHOOLID, 60\nAIC = 16259.7, DIC = 16009.6\ndeviance = 16109.7 \n```\n:::\n:::\n\n\n\nWe are just taking the model as given; this document is about showing the fit of this model.\nIn particular, if you haven't seen 3-level models before, just consider the above as some complex model; the nice thing about `predict()` is you don't even need to understand the model you are using!\nNote we do have a lot of fixed effect interaction terms, allowing for systematically different trajectories for groups of kids that are grouped on recorded race and gender.\n\n### The simple predict() approach\n\nWe can use our model to predict outcomes for each timepoint in the data.\nThis will smooth out the time to time variation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat$Yhat = predict( M4 )\nggplot( dat, aes( YEAR, Yhat, group=CHILDID ) ) +\n  facet_grid( RACEETH ~ FEMALE ) +\n  geom_line( alpha=0.25 )\n```\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-28-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nNote how the growth lines don't go across all years for all kids.\nThis is because we were missing data for those kids in the original dataset at those timepoints, so we didn't predict outcomes when we used the `predict()` function, above.\n\nTo fix this we will add in those missing timepoints so we get predictions for all kids for all timepoints.\n\n### The expand.grid() function\n\nWe now want different trajectories for the different groups.\nWe can generate fake children of each group for each school using `expand.grid()`.\nThis method will generate a dataframe with all combinations of the given variables supplied.\nHere we make all combinations of year, gender, and race/ethnic group for each school.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsynth.dat = expand.grid( CHILDID = -1,\n                         SCHOOLID = levels( dat$SCHOOLID ),\n                         YEAR = unique( dat$YEAR ),\n                         FEMALE = c( 0, 1 ),\n                         RACEETH = levels( dat$RACEETH ) )\nhead( synth.dat )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  CHILDID     SCHOOLID YEAR FEMALE RACEETH\n1      -1 2020         -0.5      0   black\n2      -1 2040         -0.5      0   black\n3      -1 2180         -0.5      0   black\n4      -1 2330         -0.5      0   black\n5      -1 2340         -0.5      0   black\n6      -1 2380         -0.5      0   black\n```\n:::\n\n```{.r .cell-code}\nnrow( synth.dat )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2160\n```\n:::\n:::\n\n\n\nThe `CHILDID = -1` line means we are making up a new child (not using one of the real ones) so the child random effects will be set to 0 in the predictions.\n\nOnce we have our dataset, we use predict to calculate the predicted outcomes for each student type for each year timepoint for each school:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsynth.dat = mutate( synth.dat, MATH = predict( M4, \n                                               newdata=synth.dat,\n                                               allow.new.levels = TRUE) )\n```\n:::\n\n\n\nNow we can plot with our new predictions\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot( synth.dat, aes( YEAR, MATH, group=SCHOOLID ) ) +\n  facet_grid( RACEETH ~ FEMALE ) +\n  geom_line( alpha=0.5 )\n```\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-31-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nHere we are seeing the different school trajectories for the six types of kid defined by our student-level demographics.\n\nOr, for a subset of schools\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsynth.dat = mutate( synth.dat, GENDER = ifelse( FEMALE, \"female\", \"male\" ) )\nkeepers = sample( unique( synth.dat$SCHOOLID ), 12 )\ns2 = filter( synth.dat, SCHOOLID %in% keepers )\nggplot( s2, aes( YEAR, MATH, col=RACEETH, lty=GENDER ) ) +\n  facet_wrap( ~ SCHOOLID ) +\n  geom_line( alpha=0.5) + geom_point( alpha=0.5 )\n```\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-32-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nHere we see the six lines for the six groups within each school, plotted in little tiles, one for each school.\n\n### Population aggregation\n\nYou can also aggregate these predictions.\nThis is the easiest way to get what collection of schools, averaging over their random effects, looks like.\n\nAggregate with the `group_by()` and the `summarise()` methods:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nagg.dat = synth.dat %>% group_by( GENDER, RACEETH, YEAR ) %>%\n  dplyr::summarise( MATH = mean( MATH ) )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'GENDER', 'RACEETH'. You can override using\nthe `.groups` argument.\n```\n:::\n\n```{.r .cell-code}\nggplot( agg.dat, aes( YEAR, MATH, col=RACEETH, lty=GENDER ) ) +\n  geom_line( alpha=0.5) + geom_point( alpha=0.5 )\n```\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-33-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nOr do this via predict directly, using the prior ideas\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsynth.dat.agg = expand.grid( CHILDID = -1,\n                             SCHOOLID = -1,\n                             YEAR = unique( dat$YEAR ),\n                             FEMALE = c( 0, 1 ),\n                             RACEETH = levels( dat$RACEETH ) )\nnrow( synth.dat.agg )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 36\n```\n:::\n\n```{.r .cell-code}\nsynth.dat.agg = mutate( synth.dat.agg, \n                        MATH = predict( M4, \n                                        newdata=synth.dat.agg,\n                                        allow.new.levels = TRUE) )\nsynth.dat.agg = mutate( synth.dat.agg, GENDER = ifelse( FEMALE, \"female\", \"male\" ) )\n\nggplot( synth.dat.agg, aes( YEAR, MATH, col=RACEETH, lty=GENDER ) ) +\n  geom_line( alpha=0.5) + geom_point( alpha=0.5 )\n```\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-34-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nThe above plot suggests that the gender gap only exists for the white children.\nIt also shows that there are racial gaps, and that the Black children appear to be falling further behind as time passes.\n\nThis block of code is stand-alone, showing the making of fake data and plotting of predictions all in one go.\nEspecially for glms, where there are nonlinearities due to the link function, this will give you the \"typical\" units, whereas the aggregation method will average over your individuals in the sample.\n\nFinally, we can also make tables to calculate observed gaps (although in many cases you can just read this sort of thing off the regression table).\nFirst `spread` our data to get columns for each race\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns3 = spread( synth.dat.agg, key=\"RACEETH\", value=\"MATH\" )\nhead( s3 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  CHILDID SCHOOLID YEAR FEMALE GENDER     black  hispanic      white\n1      -1       -1 -2.5      0   male -3.062597 -3.140761 -2.5729327\n2      -1       -1 -2.5      1 female -3.022567 -3.090730 -2.7217865\n3      -1       -1 -1.5      0   male -2.129829 -2.071721 -1.4888230\n4      -1       -1 -1.5      1 female -2.110196 -2.048891 -1.7416614\n5      -1       -1 -0.5      0   male -1.284951 -1.107972 -0.5317700\n6      -1       -1 -0.5      1 female -1.268487 -1.096511 -0.8412427\n```\n:::\n:::\n\n\n\nThen summarise:\n\n\n\n\n```{.r .cell-code}\ntab = s3 %>% group_by( YEAR ) %>% \n  summarise( gap.black.white = mean( white ) - mean( black ),\n             gap.hispanic.white = mean( white ) - mean( hispanic ),\n             gap.black.hispanic = mean( hispanic ) - mean( black ) )\nknitr::kable( tab, digits=2 )\n```\n\n::: {.cell-output-display}\n| YEAR| gap.black.white| gap.hispanic.white| gap.black.hispanic|\n|----:|---------------:|------------------:|------------------:|\n| -2.5|            0.40|               0.47|              -0.07|\n| -1.5|            0.50|               0.45|               0.06|\n| -0.5|            0.59|               0.42|               0.17|\n|  0.5|            0.65|               0.38|               0.27|\n|  1.5|            0.69|               0.34|               0.35|\n|  2.5|            0.70|               0.29|               0.41|\n:::\n\n\n\nThis again shows widening gap between Black and White students, and the closing gap of Hispanic and White students.\n\n### Plotting random effects by Level 2 variable\n\nYou can also look at estimated random effects as a function of level 2 variables.\nFor example, we can see if there is a pattern of average math score for students by year.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nranef = ranef( M4 )$SCHOOLID\nranef$SCHOOLID = rownames( ranef )\nschools = dat %>% group_by( SCHOOLID ) %>%\n  summarise( n = n(),\n             size = SIZE[[1]] )\nschools = merge( schools, ranef, by=\"SCHOOLID\" )\nhead( schools )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      SCHOOLID   n size (Intercept)        YEAR\n1 2020          97  380  0.40323695  0.15257155\n2 2040          89  502  0.11549112  0.07547119\n3 2180         168  777 -0.08149965 -0.08226575\n4 2330         150  800  0.32372001 -0.04389156\n5 2340         220 1133 -0.05151492 -0.01128209\n6 2380          87  439 -0.17018815  0.10802722\n```\n:::\n\n```{.r .cell-code}\nggplot( schools, aes( size, `(Intercept)` ) ) +\n  geom_point() +\n  geom_smooth(method=\"lm\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](plot_expand_grid_files/figure-pdf/unnamed-chunk-37-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nWe see a possible negative trend.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}