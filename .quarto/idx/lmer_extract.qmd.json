{"title":"Extrating information from fitted `lmer` models using base R","markdown":{"yaml":{"title":"Extrating information from fitted `lmer` models using base R","author":"Luke Miratrix","editor":{"markdown":{"wrap":"sentence"}}},"headingText":"Fitting and viewing the model","containsRefs":false,"markdown":"\n\n```{r loadlibs, echo=FALSE, message=FALSE, warning=FALSE}\nlibrary( lme4 )\nlibrary( foreign )\nlibrary( arm )\nlibrary( tidyverse )\nknitr::opts_chunk$set(comment = \"\")\nknitr::opts_chunk$set(width=100)\n\n```\n\nThis chapter follows Chapter @sec-broom, and provides an alternate set of ways of pulling information from a fit `lmer` model.\nIn particular, this document walks through various R code to pull information out of a multilevel model (and OLS models as well, since the methods generally work on everything).\nFor illustration, we will use a random-slope model on the HS&B dataset with some level 1 and level 2 fixed effects.\n\nWe use the following libraries in this file:\n\n```{r}\nlibrary( lme4 )\nlibrary( foreign ) ## to load data\nlibrary( arm )\nlibrary( tidyverse )\n```\n\nLoading the data is simple.\nWe read student and school level data and merge:\n\n```{r, warning=FALSE}\ndat = read.spss( \"data/hsb1.sav\", to.data.frame=TRUE )\nsdat = read.spss( \"data/hsb2.sav\", to.data.frame=TRUE )\ndat = merge( dat, sdat, by=\"id\", all.x=TRUE )\nhead( dat, 3 )\n```\n\n\nNow we fit the random slope model with the level-2 covariates:\n\n```{r}\nM1 = lmer( mathach ~ 1 + ses + meanses + (1 + ses|id), data=dat )\n```\n\nIf we just print the object, e.g., by typing the name of the model on the console, we get minimal information:\n\n```{r}\nM1\n```\n\n### The `display()` method\n\nThe `arm` package's `display()` method gives an overview of what our fitted model is:\n\n```{r}\ndisplay( M1 )\n```\n\n### The `summary()` method\n\nWe can also look at the messier default `summary()` command, which gives you more output.\nThe real win is if we use the `lmerTest` library and fit our model with that package loaded, our `summary()` is more exciting and has $p$-values:\n\n```{r, warnings=FALSE, message=FALSE}\nlibrary( lmerTest )\nM1 = lmer( mathach ~ 1 + ses + meanses + (1 + ses|id), data=dat )\nsummary( M1 )\n```\n\n## Obtaining Fixed Effects\n\nR thinks of all models in reduced form.\nThus when we get the fixed effects we get both the level-1 and level-2 fixed effects all together:\n\n```{r}\nfixef( M1 )\n```\n\nThe above is a vector of numbers.\nEach element is named, but we can index them as so:\n\n```{r}\nfixef( M1 )[2]\n```\n\nWe can also use the `[[]]` which means \"give me that element not as a list but as just the element!\" When in doubt, if you want one thing out of a list or vector, use `[[]]` instead of `[]`:\n\n```{r}\nfixef( M1 )[[2]]\n```\n\nSee how it gives you the number without the name here?\n\n## Obtaining Variance and Covariance estimates\n\nWe can get the Variance-Covariance matrix of the random effects with `VarCorr`.\n\n```{r}\nVarCorr( M1 )\n```\n\nIt displays nicely if you just print it out, but inside it are covariance matrices for each random effect group.\n(In our model we only have one group, `id`.) These matrices also have correlation matrices for reference.\nHere is how to get these pieces:\n\n```{r}\nvc = VarCorr( M1 )$id\nvc\n```\n\nYou might be wondering what all the `attr` stuff is.\nR can \"tack on\" extra information to a variable via \"attributes\".\nAttributes are not part of the variable exactly, but they follows their variable around.\nThe `attr` (for attribute) method is a way to get these extra bits of information.\nIn the above, R is tacking the correlation matrix on to the variance-covariance matrix to save you the trouble of calculating it yourself.\nGet it as follows:\n\n```{r}\nattr( vc, \"correlation\" )\n```\n\nYou can also just use the `vc` object as a matrix.\nHere we take the diagonal of it\n\n```{r}\ndiag( vc )\n```\n\nIf you want an element from a matrix use row-column indexing like so:\n\n```{r}\nvc[1,2]\n```\n\nfor row 1 and column 2.\n\n#### The `sigma.hat()` and `sigma()` methods\n\nIf you just want the variances and standard deviations of your random effects, use `sigma.hat()`.\nThis also gives you the residual standard deviation as well.\nThe output is a weird object, with a list of things that are themselves lists in it.\nLet's examine it.\nFirst we look at what the whole thing is:\n\n```{r}\nsigma.hat( M1 )\nnames( sigma.hat( M1 ) )\nsigma.hat( M1 )$sigma\n```\n\nOur standard deviations of the random effects are\n\n```{r}\nsigma.hat( M1 )$sigma$id\n```\n\nWe can get our residual variance by this weird thing (we are getting `data` from the `sigma` inside of `sigma.hat( M1 )`):\n\n```{r}\nsigma.hat( M1 )$sigma$data\n```\n\nBut here is an easier way using the `sigma()` utility function:\n\n```{r}\nsigma( M1 )\n```\n\n## Obtaining Empirical Bayes Estimates of the Random Effects\n\nRandom effects come out of the `ranef()` method.\nEach random effect is its own object inside the returned object.\nYou refer to these sets of effects by name.\nHere our random effect is called `id`.\n\n```{r}\nests = ranef( M1 )$id\nhead( ests )\n```\n\nGenerally, what you get back from these calls is a new data frame with a row for each group.\nThe rows are named with the original id codes for the groups, but if you want to connect it back to your group-level information you are going to want to merge stuff.\nTo do this, and to keep things organized, I recommend adding the id as a column to your dataframe:\n\n```{r}\nnames(ests) = c( \"u0\", \"u1\" )\nests$id = rownames( ests )\nhead( ests )\n```\n\nWe also renamed our columns of our dataframe to give them names nicer than `(Intercept)`.\nYou can use these names if you wish, however.\nYou just need to quote them with back ticks (this code is not run):\n\n```{r, eval=FALSE}\nhead( ests$`(Intercept)` )\n```\n\n### The `coef()` method\n\nWe can also get a slighly different (but generally easier to use) version these things through `coef()`.\nWhat `coef()` does is give you the estimated regression lines for each group in your data by combining the random effect for each group with the corresponding fixed effects.\nNote how in the following the `meanses` coefficient is the same, but the others vary due to the random slope and random intercept.\n\n```{r}\ncoefs = coef( M1 )$id\nhead( coefs )\n```\n\nNote that if we have level 2 covariates in our model, they are not incorperated in the intercept and slope via `coef()`.\nWe have to do that by hand:\n\n```{r}\nnames( coefs ) = c( \"beta0.adj\", \"beta.ses\", \"beta.meanses\" )\ncoefs$id = rownames( coefs )\ncoefs = merge( coefs, sdat, by=\"id\" )\ncoefs = mutate( coefs, beta0 = beta0.adj + beta.meanses * meanses )\ncoefs$beta.meanses = NULL\n```\n\nHere we added in the impact of mean ses to the intercept (as specified by our model).\nNow if we look at the intercepts (the beta0 variables) they will incorperate the level 2 covariate effects.\nIf we then plotted a line using beta0 and beta.ses for each school, we would get the estimated lines for each school including the school-level covariate impacts.\n\n## Obtaining standard errors\n\nWe can get an object with all the standard errors of the coefficients, including the individual Emperical Bayes estimates for the individual random effects.\nThis is a lot of information.\nWe first look at the Standard Errors for the fixed effects, and then for the random effects.\nStandard errors for the variance terms are not given (this is tricker to calculate).\n\n### Fixed effect standard errors\n\n```{r}\nses = se.coef( M1 )\nnames( ses )\n```\n\nOur fixed effect standard errors:\n\n```{r}\nses$fixef\n```\n\nYou can also get the uncertainty estimates of your fixed effects as a variance-covariance matrix:\n\n```{r}\nvcov( M1 )\n```\n\nThe standard errors are the diagonal of this matrix, square-rooted.\nSee how they line up?:\n\n```{r}\nsqrt( diag( vcov( M1 ) ) )\n```\n\n### Random effect standard errors\n\nOur random effect standard errors for our EB estimates:\n\n```{r}\nhead( ses$id )\n```\n\nWarning: these come as a matrix, not data frame.\nIt is probably best to do this:\n\n```{r}\nSEs = as.data.frame( se.coef( M1 )$id )\nhead( SEs )\n```\n\n## Generating confidence intervals\n\nWe can compute profile confidence intervals (warnings have been suppressed)\n\n```{r, warning=FALSE, message=FALSE, cache=TRUE}\nconfint( M1 )\n```\n\n## Obtaining fitted values\n\nFitted values are the predicted value for each individual given the model.\n\n```{r}\nyhat = fitted( M1 )\nhead( yhat )\n```\n\nResiduals are the difference between predicted and observed:\n\n```{r}\nresids = resid( M1 )\nhead( resids )\n```\n\nWe can also predict for hypothetical new data.\nHere we predict the outcome for a random student with ses of -1, 0, and 1 in a school with mean ses of 0:\n\n```{r}\nndat = data.frame( ses = c( -1, 0, 1 ), meanses=c(0,0,0), id = -1 )\npredict( M1, newdata=ndat, allow.new.levels=TRUE )\n```\n\nThe `allow.new.levels=TRUE` bit says to predict for a new school (our fake school id of -1 in `ndat` above).\nIn this case it assumes the new school is typical, with 0s for the random effect residuals.\n\nIf we predict for a current school, the random effect estimates are incorporated:\n\n```{r}\nndat$id = 1296\npredict( M1, newdata=ndat )\n```\n\n## Appendix: the guts of the object\n\nWhen we fit our model and store it in a variable, R stores *a lot* of stuff.\nThe following lists some other functions that pull out bits and pieces of that stuff.\n\nFirst, to get the model matrix (otherwise called the design matrix)\n\n```{r}\nmm = model.matrix( M1 )\nhead( mm )\n```\n\nThis can be useful for predicting individual group mean outcomes, for example.\n\nWe can also ask questions such as number of groups, number of individuals:\n\n```{r}\nngrps( M1 )\nnobs( M1 )\n```\n\nWe can list all methods for the object (`merMod` is a more generic version of `lmerMod` and has a lot of methods we can use)\n\n```{r}\nclass( M1 )\nmethods(class = \"lmerMod\")\nmethods(class = \"merMod\")\n```\n","srcMarkdownNoYaml":"\n\n```{r loadlibs, echo=FALSE, message=FALSE, warning=FALSE}\nlibrary( lme4 )\nlibrary( foreign )\nlibrary( arm )\nlibrary( tidyverse )\nknitr::opts_chunk$set(comment = \"\")\nknitr::opts_chunk$set(width=100)\n\n```\n\nThis chapter follows Chapter @sec-broom, and provides an alternate set of ways of pulling information from a fit `lmer` model.\nIn particular, this document walks through various R code to pull information out of a multilevel model (and OLS models as well, since the methods generally work on everything).\nFor illustration, we will use a random-slope model on the HS&B dataset with some level 1 and level 2 fixed effects.\n\nWe use the following libraries in this file:\n\n```{r}\nlibrary( lme4 )\nlibrary( foreign ) ## to load data\nlibrary( arm )\nlibrary( tidyverse )\n```\n\nLoading the data is simple.\nWe read student and school level data and merge:\n\n```{r, warning=FALSE}\ndat = read.spss( \"data/hsb1.sav\", to.data.frame=TRUE )\nsdat = read.spss( \"data/hsb2.sav\", to.data.frame=TRUE )\ndat = merge( dat, sdat, by=\"id\", all.x=TRUE )\nhead( dat, 3 )\n```\n\n## Fitting and viewing the model\n\nNow we fit the random slope model with the level-2 covariates:\n\n```{r}\nM1 = lmer( mathach ~ 1 + ses + meanses + (1 + ses|id), data=dat )\n```\n\nIf we just print the object, e.g., by typing the name of the model on the console, we get minimal information:\n\n```{r}\nM1\n```\n\n### The `display()` method\n\nThe `arm` package's `display()` method gives an overview of what our fitted model is:\n\n```{r}\ndisplay( M1 )\n```\n\n### The `summary()` method\n\nWe can also look at the messier default `summary()` command, which gives you more output.\nThe real win is if we use the `lmerTest` library and fit our model with that package loaded, our `summary()` is more exciting and has $p$-values:\n\n```{r, warnings=FALSE, message=FALSE}\nlibrary( lmerTest )\nM1 = lmer( mathach ~ 1 + ses + meanses + (1 + ses|id), data=dat )\nsummary( M1 )\n```\n\n## Obtaining Fixed Effects\n\nR thinks of all models in reduced form.\nThus when we get the fixed effects we get both the level-1 and level-2 fixed effects all together:\n\n```{r}\nfixef( M1 )\n```\n\nThe above is a vector of numbers.\nEach element is named, but we can index them as so:\n\n```{r}\nfixef( M1 )[2]\n```\n\nWe can also use the `[[]]` which means \"give me that element not as a list but as just the element!\" When in doubt, if you want one thing out of a list or vector, use `[[]]` instead of `[]`:\n\n```{r}\nfixef( M1 )[[2]]\n```\n\nSee how it gives you the number without the name here?\n\n## Obtaining Variance and Covariance estimates\n\nWe can get the Variance-Covariance matrix of the random effects with `VarCorr`.\n\n```{r}\nVarCorr( M1 )\n```\n\nIt displays nicely if you just print it out, but inside it are covariance matrices for each random effect group.\n(In our model we only have one group, `id`.) These matrices also have correlation matrices for reference.\nHere is how to get these pieces:\n\n```{r}\nvc = VarCorr( M1 )$id\nvc\n```\n\nYou might be wondering what all the `attr` stuff is.\nR can \"tack on\" extra information to a variable via \"attributes\".\nAttributes are not part of the variable exactly, but they follows their variable around.\nThe `attr` (for attribute) method is a way to get these extra bits of information.\nIn the above, R is tacking the correlation matrix on to the variance-covariance matrix to save you the trouble of calculating it yourself.\nGet it as follows:\n\n```{r}\nattr( vc, \"correlation\" )\n```\n\nYou can also just use the `vc` object as a matrix.\nHere we take the diagonal of it\n\n```{r}\ndiag( vc )\n```\n\nIf you want an element from a matrix use row-column indexing like so:\n\n```{r}\nvc[1,2]\n```\n\nfor row 1 and column 2.\n\n#### The `sigma.hat()` and `sigma()` methods\n\nIf you just want the variances and standard deviations of your random effects, use `sigma.hat()`.\nThis also gives you the residual standard deviation as well.\nThe output is a weird object, with a list of things that are themselves lists in it.\nLet's examine it.\nFirst we look at what the whole thing is:\n\n```{r}\nsigma.hat( M1 )\nnames( sigma.hat( M1 ) )\nsigma.hat( M1 )$sigma\n```\n\nOur standard deviations of the random effects are\n\n```{r}\nsigma.hat( M1 )$sigma$id\n```\n\nWe can get our residual variance by this weird thing (we are getting `data` from the `sigma` inside of `sigma.hat( M1 )`):\n\n```{r}\nsigma.hat( M1 )$sigma$data\n```\n\nBut here is an easier way using the `sigma()` utility function:\n\n```{r}\nsigma( M1 )\n```\n\n## Obtaining Empirical Bayes Estimates of the Random Effects\n\nRandom effects come out of the `ranef()` method.\nEach random effect is its own object inside the returned object.\nYou refer to these sets of effects by name.\nHere our random effect is called `id`.\n\n```{r}\nests = ranef( M1 )$id\nhead( ests )\n```\n\nGenerally, what you get back from these calls is a new data frame with a row for each group.\nThe rows are named with the original id codes for the groups, but if you want to connect it back to your group-level information you are going to want to merge stuff.\nTo do this, and to keep things organized, I recommend adding the id as a column to your dataframe:\n\n```{r}\nnames(ests) = c( \"u0\", \"u1\" )\nests$id = rownames( ests )\nhead( ests )\n```\n\nWe also renamed our columns of our dataframe to give them names nicer than `(Intercept)`.\nYou can use these names if you wish, however.\nYou just need to quote them with back ticks (this code is not run):\n\n```{r, eval=FALSE}\nhead( ests$`(Intercept)` )\n```\n\n### The `coef()` method\n\nWe can also get a slighly different (but generally easier to use) version these things through `coef()`.\nWhat `coef()` does is give you the estimated regression lines for each group in your data by combining the random effect for each group with the corresponding fixed effects.\nNote how in the following the `meanses` coefficient is the same, but the others vary due to the random slope and random intercept.\n\n```{r}\ncoefs = coef( M1 )$id\nhead( coefs )\n```\n\nNote that if we have level 2 covariates in our model, they are not incorperated in the intercept and slope via `coef()`.\nWe have to do that by hand:\n\n```{r}\nnames( coefs ) = c( \"beta0.adj\", \"beta.ses\", \"beta.meanses\" )\ncoefs$id = rownames( coefs )\ncoefs = merge( coefs, sdat, by=\"id\" )\ncoefs = mutate( coefs, beta0 = beta0.adj + beta.meanses * meanses )\ncoefs$beta.meanses = NULL\n```\n\nHere we added in the impact of mean ses to the intercept (as specified by our model).\nNow if we look at the intercepts (the beta0 variables) they will incorperate the level 2 covariate effects.\nIf we then plotted a line using beta0 and beta.ses for each school, we would get the estimated lines for each school including the school-level covariate impacts.\n\n## Obtaining standard errors\n\nWe can get an object with all the standard errors of the coefficients, including the individual Emperical Bayes estimates for the individual random effects.\nThis is a lot of information.\nWe first look at the Standard Errors for the fixed effects, and then for the random effects.\nStandard errors for the variance terms are not given (this is tricker to calculate).\n\n### Fixed effect standard errors\n\n```{r}\nses = se.coef( M1 )\nnames( ses )\n```\n\nOur fixed effect standard errors:\n\n```{r}\nses$fixef\n```\n\nYou can also get the uncertainty estimates of your fixed effects as a variance-covariance matrix:\n\n```{r}\nvcov( M1 )\n```\n\nThe standard errors are the diagonal of this matrix, square-rooted.\nSee how they line up?:\n\n```{r}\nsqrt( diag( vcov( M1 ) ) )\n```\n\n### Random effect standard errors\n\nOur random effect standard errors for our EB estimates:\n\n```{r}\nhead( ses$id )\n```\n\nWarning: these come as a matrix, not data frame.\nIt is probably best to do this:\n\n```{r}\nSEs = as.data.frame( se.coef( M1 )$id )\nhead( SEs )\n```\n\n## Generating confidence intervals\n\nWe can compute profile confidence intervals (warnings have been suppressed)\n\n```{r, warning=FALSE, message=FALSE, cache=TRUE}\nconfint( M1 )\n```\n\n## Obtaining fitted values\n\nFitted values are the predicted value for each individual given the model.\n\n```{r}\nyhat = fitted( M1 )\nhead( yhat )\n```\n\nResiduals are the difference between predicted and observed:\n\n```{r}\nresids = resid( M1 )\nhead( resids )\n```\n\nWe can also predict for hypothetical new data.\nHere we predict the outcome for a random student with ses of -1, 0, and 1 in a school with mean ses of 0:\n\n```{r}\nndat = data.frame( ses = c( -1, 0, 1 ), meanses=c(0,0,0), id = -1 )\npredict( M1, newdata=ndat, allow.new.levels=TRUE )\n```\n\nThe `allow.new.levels=TRUE` bit says to predict for a new school (our fake school id of -1 in `ndat` above).\nIn this case it assumes the new school is typical, with 0s for the random effect residuals.\n\nIf we predict for a current school, the random effect estimates are incorporated:\n\n```{r}\nndat$id = 1296\npredict( M1, newdata=ndat )\n```\n\n## Appendix: the guts of the object\n\nWhen we fit our model and store it in a variable, R stores *a lot* of stuff.\nThe following lists some other functions that pull out bits and pieces of that stuff.\n\nFirst, to get the model matrix (otherwise called the design matrix)\n\n```{r}\nmm = model.matrix( M1 )\nhead( mm )\n```\n\nThis can be useful for predicting individual group mean outcomes, for example.\n\nWe can also ask questions such as number of groups, number of individuals:\n\n```{r}\nngrps( M1 )\nnobs( M1 )\n```\n\nWe can list all methods for the object (`merMod` is a more generic version of `lmerMod` and has a lot of methods we can use)\n\n```{r}\nclass( M1 )\nmethods(class = \"lmerMod\")\nmethods(class = \"merMod\")\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"pygments","output-file":"lmer_extract.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","bibliography":["references.bib"],"output_dir":"docs","editor":{"markdown":{"wrap":"sentence"}},"theme":"cosmo","code-copy":true,"title":"Extrating information from fitted `lmer` models using base R","author":"Luke Miratrix"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","highlight-style":"pygments","output-file":"lmer_extract.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"output_dir":"docs","editor":{"markdown":{"wrap":"sentence"}},"documentclass":"scrreprt","title":"Extrating information from fitted `lmer` models using base R","author":"Luke Miratrix"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}